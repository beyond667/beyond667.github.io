{"meta":{"title":"工欲善其事，必先利其器","subtitle":null,"description":null,"author":"beyond667","url":"https://beyond667.github.io","root":"/"},"pages":[],"posts":[{"title":"从源码分析Activity启动过程","slug":"从源码分析Activity启动过程","date":"2019-07-09T03:00:37.000Z","updated":"2020-04-29T02:14:57.699Z","comments":true,"path":"2019/07/09/从源码分析Activity启动过程/","link":"","permalink":"https://beyond667.github.io/2019/07/09/从源码分析Activity启动过程/","excerpt":"","text":"前言这个问题Android高级别面试必备。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://beyond667.github.io/tags/Android/"}]},{"title":"Activity基础","slug":"Activity基础","date":"2019-05-24T14:00:37.000Z","updated":"2020-04-29T02:14:57.698Z","comments":true,"path":"2019/05/24/Activity基础/","link":"","permalink":"https://beyond667.github.io/2019/05/24/Activity基础/","excerpt":"","text":"前言Activity作为四大组件之一，也可以说是四大组件中最重要的一个组件，下面我们从以下几点来理解activity。 显式启动和隐式启动 生命周期 启动模式 任务栈和Affinity 显式启动和隐式启动安卓有两种方式启动Activity，一种是显示启动，这个大家经常用到，不再细述。另外一种是隐式启动，隐式启动常用于不同应用之间的跳转（例如打开支付宝微信的支付页面），也可用于H5与native之间的交互。隐式启动就是action，category和data的匹配，我们先来说下匹配的规则，然后通过具体的例子去验证。 action的匹配规则 action在Intent-filter可以设置多条 intent中必须指定action否则匹配失败且intent中action最多只有一条 intent中的action和intent-filter中的action必须完全一样时（包括大小写）才算匹配成功 intent中的action只要与intent-filter其中的一条匹配成功即可 123456789101112&lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.jrmf360.action.ENTER&quot;/&gt; &lt;action android:name=&quot;com.jrmf360.action.ENTER2&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 下面的两个intent都可以匹配上面MainActivity的action规则1234Intent intent = new Intent(&quot;com.jrmf360.action.ENTER&quot;);startActivity(intent);Intent intent2 = new Intent(&quot;com.jrmf360.action.ENTER2&quot;);startActivity(intent2); category的匹配规则 category在intent-filter和intent中都可以有多条 intent中所有的category都必须在intent-filter中找到一样的（包括大小写）才算匹配成功 通过intent启动Activity的时候如果没有添加category会自动添加android.intent.category.DEFAULT，如果intent-filter中没有添加android.intent.category.DEFAULT则会匹配失败 data的匹配规则data语法12345678&lt;data android:host=&quot;string&quot; android:mimeType=&quot;string&quot; android:path=&quot;string&quot; android:pathPattern=&quot;string&quot; android:pathPrefix=&quot;string&quot; android:port=&quot;string&quot; android:scheme=&quot;string&quot;/&gt; 举例：12345678910scheme://host:port/path|pathPrefix|pathPatternjrmf://jrmf360.com:8888/firstscheme：主机的协议部分，如jrmfhost：主机部分，如jrmf360.comport： 端口号，如8888path：路径，如firstpathPrefix：指定了部分路径，它会跟Intent对象中的路径初始部分匹配，如firstpathPattern：指定的路径可以进行正则匹配，如firstmimeType：处理的数据类型，如image/* intent-filter中可以设置多个data intent中只能设置一个data intent-filter中指定了data，intent中就要指定其中的一个data setType会覆盖setData，setData会覆盖setType，因此需要使用setDataAndType方法来设置data和mimeType 新建两个项目A和B，在A中添加几个button，点击button通过隐式启动打开B中的Activity先来看看B中隐式启动的配置123456789101112131415161718192021&lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.jrmf360.action.ENTER&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:host=&quot;jrmf360.com&quot; android:port=&quot;8888&quot; android:scheme=&quot;jrmf&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=&quot;.FirstActivity&quot;&gt;&lt;/activity&gt;&lt;activity android:name=&quot;.SecondActivity&quot;&gt;&lt;/activity&gt; B的MainActivity根据A项目传过来的参数跳转到指定的页面12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); parseData(); &#125; private void parseData() &#123; Uri data = getIntent().getData(); if (data != null)&#123; String scheme = data.getScheme(); String host = data.getHost(); int port = data.getPort(); String path = data.getPath(); String query = data.getQuery(); String message = data.getQueryParameter(&quot;message&quot;); Log.e(getClass().getSimpleName(),&quot;scheme:&quot;+scheme); Log.e(getClass().getSimpleName(),&quot;host:&quot;+host); Log.e(getClass().getSimpleName(),&quot;port:&quot;+port); Log.e(getClass().getSimpleName(),&quot;path:&quot;+path); Log.e(getClass().getSimpleName(),&quot;query:&quot;+query); if (&quot;/first&quot;.equals(path))&#123; FirstActivity.intent(this,message); finish(); &#125;else if (&quot;/second&quot;.equals(path))&#123; SecondActivity.intent(this,message); finish(); &#125; &#125; &#125;&#125; A项目按钮的点击实现1234567891011121314151617181920@Overridepublic void onClick(View v) &#123; int id = v.getId(); if (id == R.id.btn_firstActivity)&#123; Intent intent = new Intent(); intent.setAction(&quot;com.jrmf360.action.ENTER&quot;); intent.setData(Uri.parse(&quot;jrmf://jrmf360.com:8888/first?message=Hello FirstActivity&quot;)); startActivity(intent); &#125;else if (id == R.id.btn_secondActivity)&#123; Intent intent = new Intent(); intent.setAction(&quot;com.jrmf360.action.ENTER&quot;); intent.setData(Uri.parse(&quot;jrmf://jrmf360.com:8888/second?message=Hello SecondActivity&quot;)); startActivity(intent); &#125;else if (id == R.id.btn_mainActivity)&#123; Intent intent = new Intent(&quot;com.jrmf360.action.ENTER&quot;); intent.setData(Uri.parse(&quot;jrmf://jrmf360.com:8888&quot;)); startActivity(intent); &#125;&#125; 关于android.intent.action.MAIN和android.intent.category.LAUNCHER android.intent.action.MAIN：程序最先启动的Activity可以给多个Activity设置 android.intent.category.LAUNCHER：应用程序是否显示在桌面，可以给多个Activity配置 android.intent.action.MAIN和android.intent.category.LAUNCHER同时设置会在launcher显示一个应用图标，单独设置android.intent.category.LAUNCHER不会出现图标，且一个应用程序最少要有一对。也可以设置多对，这样会在系统桌面出现过个应用程序图标，每个图标代表每个入口。 生命周期7个方法：onCreate,onStart,onRestart,onResume,onPause,onStop,onDestory。以A，B（透明），C（不透明）Activity为例：A可见时:onCreate,onStart,onResume跳转到B:onPause跳转到C:onPause,onStop(C可见后调)从C返回:onRestart,onStart,onResume按Home到桌面或者电源或者口键:onPause,onStop从桌面又到A:onRestart,onStart,onResumeA后退:onPause,onStop,onDestory横竖屏切换不配置configChanges:onPause,onStop,onDestory,onCreate,onStart,onRestoreInstanceState,onResume（有人说切横屏会执行一次，切竖屏会执行两次，亲测用华为mate20都只执行一次)设置configChanges=”orientation”或者”orientation|hidden”：onConfigurationChanged。有人说orientation会重新执行一次生命周期，亲测只执行onConfigurationChanged如果C的启动模式非standard，A到C再到C，C：onPause,onNewIntent,onResume注意： onNewIntent:只有在要跳转的activity已经有并且不需要重建才会调用。比如singleTop时栈顶的ActivitA跳转到自己，或者singleTask或者singleInstance时已经存在A。 onConfigurationChanged:在系统配置（如系统语言，文字，键盘，屏幕方向等）发生变化后默认会销毁当前activity重新执行一遍生命周期，如果设置configChanges某个值，比如android:configChanges = “orientation|screenSize”，屏幕旋转的时候不会执行销毁，而是执行onConfigurationChanged。 启动模式 standard模式：默认启动模式。Activity可以有多个实例，每次启动Activity，无论任务栈中是否已经有这个Activity的实例，系统都会创建一个新的Activity实例 singleTop模式：SingleTop模式和standard模式非常相似，主要区别就是当一个singleTop模式的Activity已经位于任务栈的栈顶，再去启动它时，不会再创建新的实例,如果不位于栈顶，就会创建新的实例。 singleTask模式：SingleTask模式的Activity在同一个Task内只有一个实例，如果Activity已经位于栈顶，系统不会创建新的Activity实例，和singleTop模式一样。但Activity已经存在但不位于栈顶时，系统就会把该Activity移到栈顶，并把它上面的activity出栈。 singleInstance模式：singleInstance模式也是单例的，但和singleTask不同，singleTask只是任务栈内单例，系统里是可以有多个singleTask Activity实例的，而singleInstance Activity在整个手机操作系统里只有一个实例，启动一singleInstanceActivity时，系统会创建一个新的任务栈，并且这个任务栈只有他一个Activity。总结：前三个模式都是在同一个栈里，singleInstance是另起一个栈。假如A到B(singleInstance)再到c(非singleInstance)，这时点后退，是先返回A再返回B。这里遵循一个原则：先清空当前栈，再清空后台栈。因为AC在同一个栈，B在另一个栈，所以c后退会先到A，知道AC所在的栈清空完才会清空B。因为singleInstance整个操作系统唯一，所以适用于共享这个activity给其他应用，比如拨打电话。对于singleInstance还有两种极端例子： A到B，按home后重新打开应用，会显示A，因为默认显示默认的栈的栈顶activity。 A到C到B，再到A，这时候会显示C而不是A。因为B到A的时候，并不是开启A，而是到A所在的栈，但是当前栈顶是C所以会显示C而不是A。 任务栈和Affinity任务栈是app管理activity的一种容器，遵循先进后出原则，默认一个app有一个任务栈，由系统指定。当然用户也可以指定多个任务栈，就用到Affinity。taskAffinity这个参数标识了一个activity所需要进入的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用包名。当然，我们也可以为每个Activity都单独指定taskAffinity属性，这个属性值必须不能和报名相同，否则就相当于没指定；同时，不能就单一字符串，需要加“.”号TastAffinity属性主要和singleTask启动模式（或者action设置FLAG_ACTIVITY_NEW_TASK）或者allowTaskReparenting属性配对，1&lt;activity android:name=&quot;.BActivity&quot; android:launchMode=&quot;singleTask&quot; android:taskAffinity=&quot;com.paul.demo&quot;/&gt; 可以通过’adb shell dumpsys activity activities | grep -i run’来查看栈的信息。1234567adb shell dumpsys activity | grep -i run * ContentProviderRecord&#123;557885e u0 com.android.browser/com.tencent.mtt.browser.tms.DownloadRunningStatusProvider&#125; authority=com.android.browser.RunningStatusProvider Running activities (most recent first): Run #10: ActivityRecord&#123;1037548 u0 demo.beyond.com.blog/.activity.SecondActivity t817&#125; Run #9: ActivityRecord&#123;7dc957e u0 demo.beyond.com.blog/.activity.LifeActivity t817&#125; Run #8: ActivityRecord&#123;924fe1b u0 demo.beyond.com.blog/.MainActivity t816&#125; 其中t817指的是Task817，即栈id是817。这里以A（standard，不指定affinity）到B，再到C，栈以ab表示，BC都指定其他affinity。BC不指定singleTask：都在栈aB不指定，C单独singleTask:AB在栈a，C在栈bB指定sigleTask，C不指定：A在栈a，BC在栈bBC都指定singleTask：A在a，BC在b结论：如果指定affinity，并且这个栈还没创建，需要同样指定singleTask(singleTop也不行)才能创建新的栈并在新的栈，否则还是原栈。如果这个栈已经创建了，就不需要再指定singleTask了。 allowTaskReparenting上面的例子，如果B不指定singleTask，指定allowTaskReparenting=true也是可以的，BC都在栈b。allowTaskReparenting的作用是Activity的迁移，当allowTaskReparenting属性和TaskAffinity配合使用时，Activity可以从一个任务栈迁移到另一个任务栈。如果是同一个应用，相当于新建了taskAffinity的栈，如果不同的应用呢？假如现在有两个应用A和B，A通过隐式启动打开B应用的ActivityC页面（allowTaskReparenting=true），B有MainActivity和ActivityC。应用A打开应用B的ActivityC页面：ActivityC位于ActivityA的栈顶，即栈a。按home，点应用B：ActivityC会从应用A的栈顶移动到应用B的栈顶，这时候栈b有ActivityC和应用B的MainActivity，栈a没有ActivityC。在ActivityC页面点后退，会回到应用B的MainActivity，并从onCreate开始执行。如果B应用的ActivityC页面不设置allowTaskReparenting（默认false），从A跳转到ActivityC相当于属于应用A，再打开应用B时ActivityC不会从A应用移动到B，而是相当于打开应用B。注意：测试中发现应用A隐式启动到应用B的ActivityC页面，如果ActivityC什么都不设置，此时位于栈a;如果设置成singleTask，会新启动一个栈，这个栈属于应用A。 startActivityForResult onActivityResult setResult使用场景：一个主界面跳转到多个不同到子界面，子界面处理完后把数据返回给主界面，这种带数据的返回就可以用这种方式。 主界面startActivityForResult（intent，requestCode）：定义跳转的界面和请求码。 子界面通过setResult（resultCode，intent（可空））：定义返回码和返回数据。 主界面重写onActivityResult（requestCode，resultCode，intent）：分别是请求码，返回码，返回数据。其中，setResult方法必须在finish之前调用，activity源码中finish方法会返回result，所以如果是在finish之后setReslut数据是不会设置进去的，这时虽然onActivityResult会回调但是拿不到真实的数据。另外测试发现，setResult在子界面的onPause和onStop中也是无效的。 可以在按钮的点击事件中setResult后finish，或者在用户点返回键的时候，重写onBackPressed，在这里setResult。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://beyond667.github.io/tags/Android/"}]},{"title":"深入理解Service","slug":"深入理解Service","date":"2019-05-13T14:46:37.000Z","updated":"2020-04-29T02:14:57.699Z","comments":true,"path":"2019/05/13/深入理解Service/","link":"","permalink":"https://beyond667.github.io/2019/05/13/深入理解Service/","excerpt":"","text":"前言我们都知道，Service服务是Android的四大组件，有启动和绑定两种启动方式.如果有人问你,先启动后绑定，Service的生命周期会是怎样,先绑定后启动呢?onStartCommand返回值有什么区别？如何在Service中弹出Dialog?IntentService和Service原理？Service与进程间又是怎么通信的（IPC：Inter-Process Communication）？是不是懵逼了？ Service基础Service是一种可以在后台执行长时间运行操作的而没有用户界面的应用组件。 相对于Activity这种在前台运行有用户界面的组件，Service非常适用于去执行那些不需要和用户交互而且还要求长期运行的任务。 跟Activity一样都是运行在ui线程（main thread）中，所以不能执行耗时操作(网络请求,拷贝数据库,大文件)。 Activity耗时操作5秒，Broadcase耗时操作10秒，Service耗时操作20秒，会报ANR异常。 如果要执行耗时操作，可以用new Thread或者AsyncTask在子线程中做，也可以在manifest中设置运行在其他进程，或者用IntentService处理耗时操作。 两种启动方式启动服务 通过startService启动服务，服务处于启动状态。 会调用Service的onCreate和onStartCommand方法，这时Service与启动组件没有关系，服务会无限期的运行在后台，除非用户执行StopSelf或者stopService，另外系统在内存不足的时候也会回收。回收时会调用onDestory方法。 服务处于启动状态时，多次调用startService只会在第一次执行onCreate，但是每次都会执行onStartCommand。 我们可以在onStartCommand中接收组件传过来的Intent，但是却不能回调组件告知其处理结果，所以并不能直接与组件交互。但是可以通过在service中发送广播，在组件中接收的方式来处理service的处理结果。 绑定服务 通过bindService绑定服务，服务处于绑定状态。 会调用Service的onCreate和onBind方法，这时Service与组件处于绑定状态，组件可以通过绑定服务时创建的ServiceConnection接口直接与服务交互。 如果绑定的组件销毁，服务也会销毁。执行onUnbind方法和onDestory方法。组件也可以通过unbindService来解绑。 既绑定又启动的生命周期我们用代码来验证下： MyService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.e(&quot;==&quot;, &quot;======onCreate==&quot;); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.e(&quot;==&quot;, &quot;======onBind==&quot;); return new MyBinder(); &#125; @Override public boolean onUnbind(Intent intent) &#123; Log.e(&quot;==&quot;, &quot;======onUnbind==&quot;); return super.onUnbind(intent); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.e(&quot;==&quot;, &quot;======onStartCommand==&quot;); return START_STICKY; &#125; @Override public void onDestroy() &#123; Log.e(&quot;==&quot;, &quot;======onDestroy==&quot;); super.onDestroy(); &#125; class MyBinder extends Binder &#123; public MyService getService() &#123; return MyService.this; &#125; &#125; public void myMethod() &#123; &#125;&#125; ServiceActivity.class 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ServiceActivity extends AppCompatActivity&#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_service); ButterKnife.bind(this); &#125; @OnClick(&#123;R.id.bt_start,R.id.bt_stop,R.id.bt_bind,R.id.bt_unbind, R.id.bt_bind_important,R.id.bt_not_foreground,R.id.bt_debug_unbind&#125;) void clickView(View view) &#123; Intent intent = new Intent(ServiceActivity.this,MyService.class); switch (view.getId()) &#123; case R.id.bt_start: startService(new Intent(ServiceActivity.this,MyService.class)); break; case R.id.bt_stop: stopService(new Intent(ServiceActivity.this,MyService.class)); break; case R.id.bt_bind: bindService(intent,connection,BIND_AUTO_CREATE); break; case R.id.bt_unbind: unbindService(connection); break; default: break; &#125; &#125; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; MyService.MyBinder binder = (MyService.MyBinder)iBinder; binder.getService().myMethod(); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; Log.e(&quot;===&quot;,&quot;=====onServiceDisconnected&quot;); &#125; &#125;;&#125; 具体操作步骤(模版插入表格有问题，后面再修)：| 步骤 | 方法调用顺序 | 结论 || ———– | ——————————————————————— | —————————- || start(1),stop(2) | onCreate-&gt;onStartCommand(1)-&gt;onDestory(2) | 正常startService || start(1),start(2),stop(3) | onCreate-&gt;onStartCommand(1)-&gt;onStartCommand(2)-&gt;onDestory(3) | 多次start只第一次调用onCreate || bind(1),unbind(2) | onCreate-&gt;onBind(1)-&gt;onUnbind-&gt;onDestory(2) | 正常bindService || bind(1),bind(2),unbind(3) | onCreate-&gt;onBind(1)-&gt;null(2)-&gt;onUnbind-&gt;onDestory(3) | 多次bind不会重复调用onBind || start(1),unbind(2),stop(3) | onCreate-&gt;onStartCommand(1)-&gt;Service not registered(2) | unbind调用时必须bind || bind(1),stop(2),unbind(3) | onCreate-&gt;onBind(1)-&gt;null(2)-&gt;onUnbind-&gt;onDestory(3) | 绑定状态通过stop无效 || start(1),bind(2),stop(3),unbind(4) | onCreate-&gt;onStartCommand(1)-&gt;onBind(2)-&gt;null(3)-&gt;onUnbind-&gt;onDestory(4) | 见底 || start(1),bind(2),unbind(3),stop(4) | onCreate-&gt;onStartCommand(1)-&gt;onBind(2)-&gt;onUnbind(3)-&gt;onDestory(4) | 见底 || bind(1),start(2),unbind(3),stop(4) | onCreate-&gt;onBind(1)-&gt;onStartCommand(2)-&gt;onUnbind(3)-&gt;onDestory(4) | 见底 || bind(1),start(2),stop(3),unbind(4) | onCreate-&gt;onBind(1)-&gt;onStartCommand(2)-&gt;null(3)-&gt;onUnbind-&gt;onDestory(4) | 见底 | 我们可以看出规律：先启动后绑定和先绑定再启动，都是先onCreate。onStartCommand和onBind再根据启动和绑定调用顺序执行；先stop不会调用任何方法，后解绑会执行unbind和onDestory；先unbind只会调onUnbind并不会立即销毁，而是需要后调stop销毁。我们注意到，bindService最后一个参数我们一般用BIND_AUTO_CREATE，还有其他标识,例如：BIND_DEBUG_UNBIND，BIND_IMPORTANT，BIND_NOT_FOREGROUND。如果service未启动，设置成BIND_AUTO_CREATE绑定service后会立即执行onBind，而其他不会，只有startService之后才会执行onBind。这时候还是相当于先绑定后启动，onCreate-&gt;onBind-&gt;onStartCommand，注意这里不同的是，如果调stop，会直接调onUnbind-&gt;onDestory,就不需要再解绑了。另外这里还会调用onServiceDisconnected，有没有注意到onServiceDisconnected这个方法不管通过解绑还是stop都没调用到？对于onServiceDisconnected调用时机，官方原话是这样的: 1Called when a connection to the Service has been lost. This typically happens when the process hosting the service has crashed or been killed. This does not remove the ServiceConnection itself -- this binding to the service will remain active, and you will receive a call to onServiceConnected(ComponentName, IBinder) when the Service is next running. 服务所在的进程如果crash或者被系统杀死会回调，我杀掉app发现根本没有回调这个方法。测试结果也只有在非BIND_AUTO_CREATE绑定时stop后会回调。 onStartCommand返回值Service.class1234 public @StartResult int onStartCommand(Intent intent, @StartArgFlags int flags, int startId) &#123; onStart(intent, startId); return mStartCompatibility ? START_STICKY_COMPATIBILITY : START_STICKY;&#125; Service默认START_STICKY_COMPATIBILITY或者START_STICKY。另外还有START_NOT_STICKY和START_REDELIVER_INTENT，那么这几个参数有什么区别呢？ START_STICKY。如果Service所在的进程，在执行了onStartCommand方法后，被清理了，那么这个Service会被保留在已开始的状态，但是不保留传入的Intent，随后系统会尝试重新创建此Service，由于服务状态保留在已开始状态，所以创建服务后一定会调用onStartCommand方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null，需要我们小心处理。 START_NOT_STICKY。如果Service所在的进程，在执行了onStartCommand方法后，被清理了，则系统不会重新启动此Service。 START_REDELIVER_INTENT。如果Service所在的进程，在执行了onStartCommand方法后，被清理了，和START_STICKY一样，也会重新创建此Service并调用onStartCommand方法。不同之处在于，重新创建Service时onStartCommand方法会传入之前的intent。 START_STICKY_COMPATIBILITY。START_STICKY的兼容版本，但是不能保证被清理后onStartCommand方法一定会被重新调用。 我们注意到，onStartCommand有3个参数，intent是创建的时候传进来的，flags和startId又是什么呢？ flag有3个值，0，START_FLAG_REDELIVERY和START_FLAG_RETRY。 正常创建Service时onStartCommand传入的flags为0。 如果onStartCommand返回的是START_REDELIVER_INTENT，在service被系统清理掉重建service时，flags就是START_FLAG_REDELIVERY，intent不为null。 如果Service创建过程中，onStartCommand方法未被调用或者没有正常返回的异常情况下， 再次尝试创建，传入的flags就为START_FLAG_RETRY。 startId代表这个唯一的启动请求，每次调用startService这个startId都不同。那这个参数有什么意义呢？停止service时有4种方式，stopService，stopSelf(),stopSelf(startId),stopSelfResult(startId),前两个直接停止服务，而后两个只有传入的是最后一个startId才能停止服务。举个例子，用户停止服务的时候又来了一个新的启动请求，1，2会立即停止服务，而3，4由于没有拿到最新的startid是不会停止成功的。3和4的区别是stopSelfResult有返回布尔值。 如何在Service中启动DialogService中可以直接Toast，如果要弹dialog，只能是弹系统dialog。Myservice.class123456789101112131415161718192021222324private void showDialog() &#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(&quot;提示&quot;); builder.setMessage(&quot;这里是service弹出的系统dialog&quot;); builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); builder.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); final AlertDialog dialog = builder.create(); //在dialog show方法之前添加如下代码，表示该dialog是一个系统的dialog //8.0新特性 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY); &#125; else &#123; dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT); &#125; dialog.show(); &#125; 对于8.0以上的系统，需要申请悬浮框权限12345678if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if (!Settings.canDrawOverlays(ServiceActivity.this)) &#123; //若没有权限，提示获取. Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION); Toast.makeText(ServiceActivity.this,&quot;需要取得权限以使用悬浮窗&quot;,Toast.LENGTH_SHORT).show(); startActivity(intent); &#125; &#125; 对应的manifest中加入SYSTEM_ALERT_WINDOW权限1&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt; Service和IntentService原理通过上面的分析，我们知道Service的运行主线程，对于耗时操作可能会引起ANR，所以耗时的操作都需要放在子线程中去做。Android也提供了Service的衍生类IntentService来处理耗时操作。IntentService保留了Service原有的特性，并且将耗时的操作都放在的子线程中，通过Handler的回调方式实现了数据的返回。IntentService源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public abstract class IntentService extends Service &#123; //HandlerThread的looper private volatile Looper mServiceLooper; //通过looper创建的一个Handler对象，用于处理消息 private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; /** * 通过HandlerThread线程中的looper对象构造的一个Handler对象 * 可以看到这个handler中主要就是处理消息 * 并且将我们的onHandlerIntent方法回调出去 * 然后停止任务，销毁自己 */ private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; /** * 当我们的IntentService第一次启动的时候，onCreate方法会执行一次 * 可以看到方法里创建了一个HandlerThread * HandlerThread继承Thread，它是一种可以使用Handler的Thread * 它的run方法里通过Looper.prepare()来创建消息队列 * 并通过Looper.loop()来开启消息循环，所以就可以在其中创建Handler了 * 这里我们通过HandlerThread得到一个looper对象 * 并且使用它的looper对象来构造一个Handler对象，就是我们上面看到的那个 * 这样做的好处就是通过mServiceHandler发出的消息都是在HandlerThread中执行 * 所以从这个角度来看，IntentService是可以执行后台任务的 */ @Override public void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; /** * 通过handler发送了一个消息，把我们的intent对象和startId发送出去 */ @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; /** * 每次启动IntentService，onStartCommand()就会被调用一次 * 在这个方法里处理每个后台任务的intent * 可以看到在这个方法里调用的是上方的onStart()方法 */ @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; /** * 因为looper是无限循环轮询消息的一个机制，所以当我们销毁时需要调用它的quit()方法来终止 */ @Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; @Override @Nullable public IBinder onBind(Intent intent) &#123; return null; &#125; /** * 这就是IntentService中定义的抽象方法 * 具体交由它自己的子类来实现 */ @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent);&#125; 通过源码看到： IntentService继承Service，专门处理异步请求。所以用法跟Service基本一样，但只能通过startService来启动。 IntentService的onBind方法返回null，所以如果你通过onBind启动的话相当于绕过IntentService的onStartCommand方法，也就绕过了handler的sendMessage方法，在你自定义的service的onHandleIntent方法就不会被调用，相当于你没用IntentService而是用的普通Service。 IntentService本质上是通过HandlerThread，Message，Looper实现的在service中的异步线程消息处理机制。 onStart方法在Service的生命周期中不会执行，但是在IntentService中会在onStartCommand后执行，另外在子类的onStartCommand方法中不能直接return START_STICKY等，而是super.onStartCommand。 在所有的looper任务处理结束后会将自身服务关闭，不需要用户手动的停止服务。具体使用请参照链接：IntentService使用例子 Service与进程间通信（IPC）- AIDLAIDL(Android Interface Definition Language，即Android接口定义语言),用于定义服务器和客户端通信接口的一种描述语言，可以拿来生成用于 IPC 的代码, AIDL这门语言的目的就是为了实现进程间通信，可以在一个进程中获取另一个进程的数据和调用其暴露出来的方法，从而实现进程间通信。 AIDL语法 服务端定义AIDL文件。在src目录下新建.aidl文件。写完后build后会生成java文件。IMyAidlInterface.aidl12345//即使IMyListener在同一目录下，也需要手动import进来，android studio不会自动引入import demo.beyond.com.blog.IMyListener;interface IMyAidlInterface &#123; void operation(int parameter1 , int parameter2, IMyListener listener);&#125; IMyListener.aidl123interface IMyListener &#123; void onSuccess(in int result);&#125; AIDL支持的数据类型分为如下几种：1 八种基本数据类型：byte、char、short、int、long、float、double、boolean，String，CharSequence2 实现了Parcelable接口的数据类型3 List 类型。List承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象4 Map类型。Map承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象 写服务端服务。AIDLService.java1234567891011121314151617181920212223242526272829303132public class AIDLService extends Service&#123; private static final String TAG = &quot;AIDLService&quot;; public AIDLService() &#123; &#125; //这里定义的aidl.Stub就是IBinder接口。这里模拟服务端处理耗时请求，之后通过回调onSuccess告诉客户端结果 private IMyAidlInterface.Stub stub = new IMyAidlInterface.Stub() &#123; @Override public void operation(int param1, int param2, IMyListener listener) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; listener.onSuccess(param1*param2); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; Toast.makeText(this,&quot;服务绑定成功&quot;,Toast.LENGTH_LONG).show(); return stub; &#125;&#125; 这样服务端就写好了。 客户端复制服务端的aidl文件，build后只需要调用服务端方法就可以1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private IMyAidlInterface iMyAidlInterface;private IMyListener mCallback = new IMyListener.Stub() &#123; @Override public void onSuccess(int result) throws RemoteException &#123; resultTv.setText(&quot;&quot; + result); &#125;&#125;;private void initView() &#123; findViewById(R.id.botton).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String params1 = params1Tv.getText().toString(); String params2 = params2Tv.getText().toString(); try &#123; if (iMyAidlInterface == null) &#123; Toast.makeText(MainActivity.this, &quot;没注册&quot;, Toast.LENGTH_LONG).show(); &#125; else &#123; iMyAidlInterface.operation(Integer.parseInt(params1), Integer.parseInt(params2), mCallback); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); findViewById(R.id.bind).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; bindService(); &#125; &#125;);&#125;//只能通过包名和aidl服务全名来绑定private void bindService() &#123; Intent intent = new Intent(); intent.setClassName(&quot;demo.beyond.com.blog&quot;, &quot;demo.beyond.com.blog.service.AIDLService&quot;); bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);&#125;private ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, final IBinder service) &#123; iMyAidlInterface = IMyAidlInterface.Stub.asInterface(service); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; iMyAidlInterface = null; &#125;&#125;; 这里客户端只能通过bind方式绑定远程服务，onServiceConnected回调后端IBinder就是远程端AIDLService，客户端就可以调用服务端AIDLService实现端方法，服务端可以通过传进来的回调对象，调用回调方法onSuccess来通知客户端处理结果。Demo链接：服务端 IMyAidlInterface.aidlAIDLService.java客户端 ClientActivity.java 使用场景一般普通的异步任务，比如网络请求，数据库或者文件相关操作，我们都会使用线程池的方式来做，因为这样使用的系统开销小，运行效率高，而且随着业务逻辑的复杂度增加，扩展性也更强。然而，对于一些特殊场景，比如进程保活，使用第三方SDK服务比如地图，IM等，就需要使用Service来实现，因为这些服务一般与App主进程隔离开，需要运行在新进程中以防止App主进程发生异常崩溃时，牵连第三方服务也挂掉。进程保活后面会专门研究。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://beyond667.github.io/tags/Android/"}]},{"title":"多线程的同步机制：Synchronized volatile ReentrantLock wait&notify","slug":"多线程的同步机制：Synchronized volatile ReentrantLock wait&notify","date":"2019-05-11T14:32:37.000Z","updated":"2020-04-29T02:14:57.699Z","comments":true,"path":"2019/05/11/多线程的同步机制：Synchronized volatile ReentrantLock wait&notify/","link":"","permalink":"https://beyond667.github.io/2019/05/11/多线程的同步机制：Synchronized volatile ReentrantLock wait&notify/","excerpt":"","text":"前言多线程的同步机制是java的基础。先看一个案例：现在有100张火车票，有两个窗口同时抢火车票，请使用多线程模拟抢票效果。看这道题目，我们首先想到的是两个线程同时访问一个共享的100张火车票的数据，每当访问一次就把火车票减1，直到为0。这里有一个问题，怎么保证线程1访问当是最新当数据，以及线程1买过票后线程2拿到的是最新的数据，那么这里就牵涉到线程安全问题。 线程安全 12当多个线程同时共享同一个全局变量或者静态变量时，做写的操作时，可能会发生数据冲突的问题，这就是线程安全的问题。注：做读操作不会发生线程安全问题。 有多种方式可以实现多线程的同步，Synchronized，ReentrantLock，volatile，wait&amp;notify，我们来分别学习一下。 Synchronizedsynchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码（锁的是小括号里传的对象或者类） 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象（锁的是调用对象） 修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象（锁的是类） 修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象（锁的是类） Synchronized原理JVM基于进入和退出Monitor对象来实现代码块同步和方法同步，两者实现细节不同。 代码块同步：在编译后通过将monitorenter指令插入到同步代码块的开始处，将monitorexit指令插入到方法结束处和异常处。通过反编译字节码可以观察到，任何一个对象都有一个monitor与之关联，线程执行monitorenter指令时，会尝试获取对象对应的monitor的所有权，即尝试获得对象的锁。 方法同步：synchronized方法在method_info结构有ACC_synchronized标记，线程执行时会识别该标记，获取对应的锁，实现方法同步。 两者虽然实现细节不同，但本质上都是对一个对象的监视器（monitor，也叫对象锁）的获取。任意一个对象有且仅有一个 自己的监视器，当同步代码块或同步方法时，执行方法的线程必须先获得该对象的监视器才能进入同步块或同步方法，没有获取到监视器的线程将会被阻塞，并进入同步队列，状态变为BLOCKED。当成功获取监视器的线程释放了锁后，会唤醒阻塞在同步队列的线程，使其重新尝试对监视器的获取。 思考：如果同步的方法又调用了另一个同步方法，会重新获取对象锁吗？答案是不会！因为Synchronized是可重入锁，试想一下，如果同步的方法调用另一个方法要重新获取锁，但是这个锁自己已经持有了，重新获取锁又要等自己释放，这不就死锁了吗？ 可重入锁123若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。 通俗来说：当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞。所以在 java 内部，同一线程在调用自己类中其他 synchronized 方法/块或调用父类的 synchronized 方法/块都不会阻碍该线程的执行。就是说同一线程对同一个对象锁是可重入的，而且同一个线程可以获取同一把锁多次，也就是可以多次重入。因为java线程是基于“每线程（per-thread）”，而不是基于“每调用（per-invocation）”的（java中线程获得对象锁的操作是以线程为粒度的)。 可重入锁原理每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。 ReentrantLockReentrantLock是jdk1.5之后提供的一套互斥锁，与Synchronized关键字类似，但提供了一些高级功能。 等待可中断。持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。 公平锁。多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。 锁绑定多个条件。一个ReentrantLock对象可以同时绑定多个Condition对象。ReentrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。 ReentrantLock使用12345678Lock lock = new ReentrantLock(); //如果构造函数加true参数，则是公平锁lock.lock(); // 加锁位于try外面，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁释放。try &#123; // update object state &#125; finally &#123; lock.unlock(); &#125; ReentrantLock原理ReentrantLock的实现是一种自旋锁，通过循环调用CAS操作(乐观锁的实现就是基于CAS操作)来实现加锁。在线程竞争很激烈但情况下它的性能比Synchronized好也是因为避免了使线程进入内核的阻塞状态。ReentrantLock用的是乐观锁，Synchronized用的是悲观锁。下面看几个概念。 互斥锁指的是一次最多只能有一个线程持有的锁。互斥锁通过锁机制来实现线程间的同步。ReentrantLock和Synchronized都属于互斥锁。 自旋锁是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。优点： 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。（线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能） 缺点： 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高 自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁(共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程)。乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。 CAS(Compare And Swap)首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作，CPU会将旧的数值返回。简单的来说，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。这是一种乐观锁的思路，它相信在它修改之前，没有其它线程去修改它；而Synchronized是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。 CAS的ABA问题 线程1在共享变量中读取到的数据A 线程2把数据从A改成B，再改成A 线程1读共享数据还是A，认为没有改变，继续执行。虽然变量的值没有改变，但是数据确实是改变了。可以使用版本号机制或者CAS算法来避免这个问题。 Synchronized和ReentrantLock比较相似点它们都是加锁方式同步，而且都是阻塞式的同步，也就是说如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待。 区别 对于Synchronized来说，它是java的关键字，是原生语法层面的互斥，需要jvm通过monitorEnter和monitorExit指令来实现。而ReentrantLock是jdk1.5之后提供的API层面的互斥锁，需要lock和unlock方法配合try/finally来完成。 Synchronized使用比较简洁，由编译器去保证锁的加锁和释放。而ReentrantLock需要手动声明加锁和释放，如果忘记会到你死锁。 ReentrantLock灵活性和细度来说更好，因为由用户自己按自己需求控制解锁和释放。 ReentrantLock增加的3个特性，可以通过lockInterruptibly来实现等待可中断，通过构造函数new ReentrantLock(true)来设置公平锁，通过Condition绑定多个条件，来实现分组唤醒。 适用场景 Synchronized在资源竞争不是很激烈的情况下(大部分synchronized块几乎从来都没发生过争用)，或者偶尔会有同步是很合适的（线程少）。如果有大量线程同时竞争，ReentrantLock是很合适的。所以大部分情况下都用Synchronized，直到确实证明不适合。java官方也建议用Synchronized 只有你确实需要ReentrantLock的3个特性的时候才考虑这个。 volatilevolatile是java的关键字，用来声明变量的值可能随时会被别的线程修改，使用volatile修饰的变量会强制将修改后的值写入主存。 可见性。在多线程环境，共享变量的操作对于每个线程来说，都是内存可见的，也就是每个线程获取的volatile变量都是最新值；并且每个线程对volatile变量的修改，都直接刷新到主存。 有序性。禁止指令重排序。为了优化编译速度，编译器在编译代码的时候并不是按照顺序编译，能保证结果一致但是不能保证编译过程一致。这在单线程处理中没任何问题，但在多线程中由于执行顺序不可控会影响到执行的正确性。volatile禁止重排序底层实现原理是加上lock前缀指令，lock后就是一个原子操作，会使cpu发一条lock信号，确保多线程竞争的环境下互斥的使用这个内存地址，执行完之后这个lock动作就会消失(对比synchronized的重量级锁，这个更底层更轻量，消耗代价更小）。lock前缀就相当于一个内存屏障，用来实现对内存操作的顺序限制。volatile就是通过内存屏障来实现的。内存屏障相当于告诉编译器这个命令必须先执行，这样其他线程读取被volatile修饰的数据会先去主内存中获取最新值，这也是实现可见性的基础。 不具备原子性。为了保证线程安全，还是需要加锁来保证原子性，所以使用场景非常有限。由于volatile不会像加锁那样线程阻塞，所以非常适合于读操作远远大于写操作。volatile原理处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完之后并不会立即写到内存，如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。适用场景 读多写少 可用作状态标示对于开头提的卖票问题，由于volatile修饰的变量自增自减不具备原子性，显然是不适用的。这种情况下可以用AtomicInteger类来保证原子性。AtomicInteger的自增自减具有原子性底层原理也是先自增自减，再通过CAS操作来保证原子性的。 wait &amp;&amp; notify/notifyAll Object基础类的final方法，不能重写，不是Thread的方法。因为每个对象都有一个锁，这三个方法是最基础的锁操作。 调用以上方法一定要加锁，否则会抛IllegalMonitorStateException锁状态异常。所以一般要在Synchronized同步代码块中。 调用wait时会释放当前的锁，进入blocked状态，直到notify/notifyAll被执行，才会唤醒一个或者多个处在等待状态的线程，然后继续往下执行，直到执行完Synchronized代码块或者继续wait，再次释放锁。也就是说notify只是唤醒线程，而不会立即释放锁。 wait需要被try/catch包围，中断也会使wait的线程唤醒。另外尽量在while循环中而不是if中使用wait。 假如有3个线程执行了obj.wait(),那么obj.notifyAll()能全部唤醒这三个线程，但是要继续执行wait的下一条语句，必须先获得Obj的锁。假如线程1获取到了锁，其他的线程需要等待线程1释放obj锁才能继续执行。 当调用notify后，调用线程依然持有obj锁，因此，3个线程虽然被唤醒，但是仍无法获取到obj锁，直到调用线程退出Synchronized块，释放obj锁之后这3个线程才有机会获得锁继续执行。 适合生产者消费者模型 生产者消费者模型假设有一个公共的容量有限的池子，有两种人，一种生产者，一种消费者。生产者往池子里添加产品，如果池子满了就停止生产，直到池子里的产品被消耗能重新放进去。消费者消耗池子里的资源，如果池子里资源为空则停止消耗，直到池子里有产品。不解释了，直接上代码，池子数量以及生产者和消费者数量可以自己设置。 另外Synchronized,ReentrantLock,以及Volatile实现开头那问题的见链接： synchronized实现卖票 ReentrantLock实现卖票 volatile实现卖票 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class SaleTrainTestWait &#123; private Ticket mTicket = new Ticket(); public void produce() &#123; synchronized (this) &#123; while (mTicket.isFull()) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;池子已经满了，售票员等待中。。。&quot; + mTicket.innerList.size()); wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; mTicket.add(); notifyAll(); &#125; &#125; public void consume() &#123; synchronized (this) &#123; while (mTicket.isEmpty()) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;池子已经空了,买家等待中。。。&quot; + mTicket.innerList.size()); wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; mTicket.remove(); notifyAll(); &#125; &#125; private class Ticket &#123; private static final int MAX_CAPACITY = 10; private List innerList = new ArrayList&lt;&gt;(MAX_CAPACITY); void add() &#123; if (isFull()) &#123; throw new IndexOutOfBoundsException(); &#125; else &#123; innerList.add(new Object()); &#125; System.out.println(Thread.currentThread().getName() + &quot; 生产后池子剩余&quot; + innerList.size()); &#125; void remove() &#123; if (isEmpty()) &#123; throw new IndexOutOfBoundsException(); &#125; else &#123; innerList.remove((innerList.size() - 1)); &#125; System.out.println(Thread.currentThread().getName() + &quot; 消费后池子剩余&quot; + innerList.size()); &#125; boolean isEmpty() &#123; return innerList.isEmpty(); &#125; boolean isFull() &#123; return innerList.size() == MAX_CAPACITY; &#125; &#125; static SaleTrainTestWait sth = new SaleTrainTestWait(); public static void main(String[] args) &#123; Product productRun = new Product(); Consume consumeRun = new Consume(); //如果只有一个买家和售票员// new Thread(consumeRun, &quot;买家&quot;).start();// new Thread(productRun, &quot;售票员&quot;).start(); //多个买家 多个售票员 for (int i = 0; i &lt; 10; i++) &#123; new Thread(consumeRun,&quot;买家&quot;+i).start(); &#125; for (int i = 0; i &lt; 10; i++) &#123; new Thread(productRun,&quot;售票员&quot;+i).start(); &#125; &#125; static class Product implements Runnable &#123; int count = 10000; @Override public void run() &#123; while (count-- &gt; 0) &#123; sth.produce(); &#125; &#125; &#125; static class Consume implements Runnable &#123; int count = 10000; @Override public void run() &#123; while (count-- &gt; 0) &#123; sth.consume(); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://beyond667.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://beyond667.github.io/tags/Java/"}]},{"title":"Hexo搭建github博客","slug":"Hexo搭建github博客","date":"2019-04-13T14:32:37.000Z","updated":"2020-04-29T02:53:09.827Z","comments":true,"path":"2019/04/13/Hexo搭建github博客/","link":"","permalink":"https://beyond667.github.io/2019/04/13/Hexo搭建github博客/","excerpt":"","text":"前言想静下心来专门写些博客，可以选择简书或者csdn等，甚至可以自己搭个服务器买个域名玩，不过最省钱最快速逼格再高一点点的我认为还是用github.io上面写。 花了一天时间终于玩通了Hexo，并且关联到github上，遇到一点点小坑，记录下来，希望后面玩的同学不要踩同样的坑。 准备工作 安装node.js，Git（省略，去官网下载安装） Github上创建新的项目 。 注意在Setting中Repository name必须是你的用户id+.github.io命名，你不可以任性的起其他任何名字，否则你就会像我一样卡在这里浪费大量时间。 搭建Hexo环境 安装：npm install -g hexo 初始化：hexo init 生成：hexo g (g是generate的缩写) 运行：hexo s (s是server的缩写) 发布：hexo d (d是deploy的缩写) 发布的时候需要修改根目录下_config.yml文件的deploy 1234deploy: type: git repository: git@github.com:beyond667/beyond667.github.io.git branch: master 注意：Windows安装hexo如果遇到这种错误：1npm ERR! notsup Unsupported platform for fsevents@1.0.14: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; 是因为node高版本会强制在window下安装fsevent,而fsevent只会在mac系统上可用，所以指定安装npm老版本1npm install-g npm@3.10.7 更换Hexo主题我认为这个是Hexo的亮点了，可以去hexo的官网找一些漂亮的主题，这样你的博客就美观多了。Hexo官网主题链接 使用起来也是超级简单。 1git clone https://github.com/huyingjie/hexo-theme-A-RSnippet.git themes/a-rsnippet 下载完的主题会在themes/a-rsnippet下，这时候需要修改根目录下_config.yml的theme。 1theme: a-rsnippet 应用完需要clean下hexo,再重新生成和运行就能看到新的主题。 123hexo cleanhexo ghexo s 修改模版很多时候你下载的模版会带一些默认的信息，比如用户，背景图片，版权等，要修改这些信息，你需要到themes/你的模版/layout/_parrtial文件夹下修改 header footer等模版信息，你自己新加的图片资源需要放到themes/你的模版/source/img文件夹下，引用的时候直接/img/图片名字就可以了。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://beyond667.github.io/tags/Hexo/"}]}]}